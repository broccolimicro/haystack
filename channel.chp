#include "math.chp"

record dualrail
{
	node<1> t;
	node<1> f;
	require(~t | ~f);
}

channel achan4p0b
{
	node<1> r;
	node<1> a;
	
	operator!()
	{
		r+; [a]; r-; [~a];
	}
	
	operator?()
	{
		[r]; a+; [~r]; a-;
	}
	
	operator#()
	{
		r
	}
}

channel achan4p1b
{
	dualrail r;
	node<1> a;
	
	operator!(node<1> i)
	{
		/* This causes an isochronic fork.
		 * [	i  -> r.t,r.f := 1,0
		 * []	~i -> r.t,r.f := 0,1
		 * ];[a]; r.t,r.f := 0,0; [~a];
		 */
		 
		[	i	-> r.t,r.f := 1,0; [a]; r.t,r.f := 0,0;
		[]	~i	-> r.t,r.f := 0,1; [a]; r.t,r.f := 0,0;
		];[~a];
	}
	
	operator?(node<1> i)
	{
		[ r.t&~r.f -> i+
		[]~r.t&r.f -> i-
		]; a+; [~r.t & ~r.f]; a-;
	}
	
	operator#()
	{
		r.t|r.f
	}
}

channel achan2p0b
{
	node<1> r;
	node<1> a;
	
	operator!(node<1> i)
	{
		[   r -> r-;[~a]
		[] ~r -> r+;[ a]
		]
	}
	
	operator?(node<1> i)
	{
		[   a -> [~r];a-
		[] ~a -> [ r];a+
		]
	}
	
	operator#()
	{
		r
	}
}

channel achan2p1b
{
	dualrail r;
	node<1> a;
	
	operator!(node<1> i)
	{
		[   r -> r.t,r.f:=0,0;[~a]
		[] ~r -> [ i  ->  r.t,r.f:=1,0
				 []~i ->  r.t,r.f:=0,1
				 ];[ a]
		]
	}
	
	operator?(node<1> i)
	{
		[   a -> [~r.t & ~r.f];a-
		[] ~a -> [ r.t -> i+
				 []r.f -> i-
				 ];a+
		]
	}
	
	operator#()
	{
		r.t|r.f
	}
}