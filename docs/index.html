<html>
<head>
<title>Getting Started with CHP</title>
</head>

<body>

<h1>Getting Started with CHP</h1>
<strong>By Ned Bingham</strong><br>

<h2>Table of Contents</h2>
<ul>
	<li><strong>How to Use the Compiler</strong></li>
	<ul>
		<li><a href="exe/basic.html">Basic Compilation Procedure</a></li>
	</ul>
	<li><strong>Introduction to the CHP Language</strong></li>
	<ul>
		<li><a href="#Commenting Code">Commenting Code</a></li>
		<li><a href="#Nodes and Records">Nodes and Records</a></li>
		<li><a href="#Assignments and Guards">Assignments and Guards</a></li>
		<li><a href="#Sequential and Parallel Composition">Sequential and Parallel Composition</a></li>
		<li><a href="#Defining Processes">Defining Processes</a></li>
		<li><a href="#Conditionals and Loops">Conditionals and Loops</a></li>
		<li><a href="#Operators and Expressions">Operators and Expressions</a></li>
		<li><a href="#Channels and Communication">Channels and Communication</a></li>
		<li><a href="#Debug Functions">Debug Functions</a></li>
		<li><a href="#The Precompiler">The Precompiler</a></li>
	</ul>
	<li><strong>Summary of the Compilation Procedure</strong></li>
	<ul>
		<li><a href="comp/hse.html">Handshaking Expansion</a></li>
		<li><a href="comp/sse.html">State Space Elaboration</a></li>
		<li><a href="comp/svi.html">State Variable Insertion</a></li>
		<li><a href="comp/gs.html">Guard Strengthening</a></li>
		<li><a href="comp/bsvi.html">Bubbleless State Variable Insertion</a></li>
		<li><a href="comp/bgs.html">Bubbleless Guard Strengthening</a></li>
		<li><a href="comp/code.html">Internal Documentation</a></li>
	</ul>
</ul>

<h1>Chapter 1: How to Use the Compiler</h1>

<h1>Chapter 2: Introduction to the CHP Language</h1>

<a id="Commenting Code"><h2>Commenting Code</h2></a>
<P>The first thing to know is how to comment. Comments are text within your CHP that are ignored during compilation. This allows you to write notes to yourself that explain why you implemented something a certain way. CHP uses the same commenting style found in C or C++. There are two types of comments: line and block comments. The line comment starts at the double slash or <code><font color="red">//</font></code> and continues until the end of the line. The block comment starts at the slash start or <code><font color="red">/*</font></code> and continues until the star slash or <code><font color="red">*/</font></code>.</P>

<pre>
<font color="red">/* This is a
block comment */</font>

...code... <font color="red">// This is a line comment!</font>
</pre>

<a id="Nodes and Records"><h2>Nodes and Records</h2></a>
<P>A <a href="https://en.wikipedia.org/wiki/Node_%28circuits%29">node</a> is the connecting metal or wire between two or more elements in a circuit. It may or may not be driven by state holding circuitry and is generally thought of as a variable in CHP.</P>

<pre>
<font color="blue">node</font><<i>width</i>> mynode
<font color="blue">node</font><<i>width</i>> mynode := <i>expression</i>
</pre>

<P>If you declare a node called mynode with a width of 3, then mynode actually refers to three different nodes of width 1: mynode[0], mynode[1], and mynode[2]. The expression is optional and acts exactly the same way as an assignment.</P>

<P>A record is a non-recursive collection of nodes and other records. It is simply a way to facilitate the organization of larger circuits. Defining a record is much the same as defining a structure in C. All statements in a record definition must be separated by semicolons. If a node is declared with an expression inside a record, then that expression must be a constant numerical value. There are three bases that are supported: binary, decimal, and hexidecimal. That value represents the reset value for that particular node.</P>

<pre>
<font color="blue">record</font> dualrail
{
	node<1> t := 0;
	node<1> f := 0;
}

<font color="blue">record</font> myrecord
{
	dualrail d1;
	dualrail d2;
	node<4> mynode_dec := 13;
	node<4> mynode_hex := 0xD;
	node<4> mynode_bin := 0b1101;
}
</pre>

<P>To access a member of a record you use the dot operator. For example, if you instantiate <code>myrecord mine</code>, then <code>mine.d1.t</code> accesses the <code>t</code> node in the <code>d1</code> dualrail in the <code>mine</code> myrecord.</P>

<a id="Assignments and Guards"><h2>Assignments and Guards</h2></a>

<a id="Sequential and Parallel Composition"><h2>Sequential and Parallel Composition</h2></a>

<a id="Defining Processes"><h2>Defining Processes</h2></a>
<P>A process is a mostly self-contained piece of hardware that communicates with other processes through either channels or shared variables. In more general terms, it represents a way of compartmentalizing certain functionalities to facilitate proof of correctness and power management, and increase modularity. A process in CHP is defined similarly to a function in C or C++.</P>

<pre>
<font color="blue">process</font> my_proc( <i>...Inputs and Outputs...</i> )
{
	...code...
}
</pre>

<P>Instantiating a process is, again, very similar to calling a function in C or C++. You must instantiate a process inside another process, and the process you instantiate must be defined <i>before</i> instantiation.</P>

<pre>
<font color="blue">process</font> other_proc( <i>...Inputs and Outputs...</i> )
{
	my_proc( ... )
}
</pre>

<P>Every process has a dataless channel named <i>call</i> that facilitates calling this process from another. During compilation, a communication action across the <i>call</i> channel is wrapped around the code that defines the process, allowing the process instantation above to be rewritten as follows.</P>

<pre>
<font color="blue">process</font> my_proc( <i>...Inputs and Outputs...</i> )
{
	*[[call.r]; ...code...; call.a+; [~call.r]; call.a-]
}

<font color="blue">process</font> other_proc( <i>...Inputs and Outputs...</i> )
{
	call.r+; [call.a]; call.r-; [~call.a]
}
</pre>

If you don't want this call structure to be automatically generated, then you may append the <code><font color="blue">inline</font></code> keyword to the beginning of the process definition. However, this also changes the way instantiation works. Instead of the instantiation being rewritten as a channel communication, the code for the instantiated process is copied directly into the instantiating process during compilation as follows.</P>

<pre>
<font color="blue">inline process</font> my_proc( <i>...Inputs and Outputs...</i> )
{
	...code...
}

<font color="blue">process</font> other_proc( <i>...Inputs and Outputs...</i> )
{
	...my_proc's code...
}
</pre>

<a id="Conditionals and Loops"><h2>Conditionals and Loops</h2></a>
<a id="Operators and Expressions"><h2>Operators and Expressions</h2></a>
<a id="Channels and Communication"><h2>Channels and Communication</h2></a>
<a id="Debug Functions"><h2>Debug Functions</h2></a>
<a id="The Precompiler"><h2>The Precompiler</h2></a>

<h1>Chapter 3: Summary of the Compilation Procedure</h1>

</body>
</html>