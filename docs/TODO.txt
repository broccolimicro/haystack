Compiler TODO list

Fix expression expansion
	Expressions with constants currently don't work. It doesn't know how
	to identify their type.

Zip:
	Find a condition in which it is legal to zip up two transitions of 
	the same value when their output arcs have the same values, but 
	their input arcs do not. This zipping will create a parallel merge 
	instead of a conditional merge. It will probably have to be 
	processed separately after all of the rest of the zipping as been 
	applied.

Variable instantiation parse:
	Allow for instantiate and assign in one instruction. Allow for the 
	instantiation of multiple variables of the same type in one 
	instruction.

State space generation:
	Plug known values into passive transitions (guards).

Miscellaneous:
	Flesh out the error handling archecture. As of now errors are simply 
	printed to the screen and don't stop the compilation even if that 
	error would cause the compiler to crash later on. Make sure to try 
	to identify every possible failure point and create a message for 
	that. Also, create documentation for that message.

Simulate:
	Deadlock Checking
	Untangle synchronization events
	Determine when a guard is unstable (i.e. we need a synchronizer instead of just an arbiter)

Miscellaneous:
	Make sure that arbitration works. Right now I do not handle the thin 
	bar.

Miscellaneous:
	Allow for interprocess shared variable checks. For example, if two 
	processes are using the send functionality of a channel, make sure 
	that the two processes are not conflicting with eachother and causing 
	a short.

Miscellaneous:
	Allow the user to insert a "prs" block.

Refactoring:
	Move everything out of utility.h. The file is unessessary and 
	problematic. common.h should be able to handle a lot of that same 
	stuff.

Assertions
	Sidenote... Embed Perl, allow user to write their own functions to do this kind of thing...

Assumptions
	process p(args...) : assume(DI)		// Asynchronous Delay Insensitive
	{
	}

	process p(args...) : assume(QDI)	// Asynchronous Quasi Delay Insensitive, isochronic fork
	{
	}

	process p(args...) : assume(BOUNDED)	// Asynchronous Bundled Data, bounded delay
	{
	}

	process p(args...) : assume(MESOSYNC)	// MesoSynchronous, interference
	{
	}

	process p(args...) : assume(SYNC)	// Synchronous, instability
	{
	}

Expand Inconsistent Branches:
	Example:
	[	i  -> r.t,r.f := 1,0
	[]	~i -> r.t,r.f := 0,1
	];[a]; r.t,r.f := 0,0; [~a];
	into
	[	i  -> r.t,r.f := 1,0;[a]; r.t,r.f := 0,0;
	[]	~i -> r.t,r.f := 0,1;[a]; r.t,r.f := 0,0;
	]; [~a];


Handshaking reshuffling
Production Rule Reduction
Bubble Reshuffling
	Approach One: synthesize blindly and hope that bubble reshuffling will work. I can implement this
	now, and it would allow me to concentrate on fixing up guard strengthening, but the probability
	of this actually working for a particular circuit is very low. This means that I would have to
	go back after a failed bubble reshuffle attempt and try to fix the state space to enable bubble
	reshuffling. This would be very difficult and inefficient since you would have to go backward
	in the synthesis and throw out a bunch of work.
	
	Approach Two: try to guarantee (somehow) that bubble reshuffling will work. Examine what negative
	cycles in production rules look like in the state space. Maybe I can find these and eliminate them
	with state variable insertions (or handshake reshufflings). Also look at the other two failure cases
	{(a -> b+, a -> b-) and (a & G1 | ~a & G2 -> b+)}. 
	
	Approach Three: just synthesize production rules that don't need to be bubble reshuffled. Find all three
	failure cases and fix them just like in approach two. But then also insert state variables that remove
	bubbles. This is the most difficult approach.

Performance analysis (Power, Timing, ect)
Comment Code