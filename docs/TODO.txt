Compiler TODO list

Production rule generation:
	Iterate through every variable and try to smooth it out of a 
	given state. If this creates a conflict, don't do it. This is a 
	difficult  problem since The order in which you process the states 
	matters, and the order in which you smooth out the variables 
	matters. This will shrink the production rules to their minimal 
	size.

Zip:
	Find a condition in which it is legal to zip up two transitions of 
	the same value when their output arcs have the same values, but 
	their input arcs do not. This zipping will create a parallel merge 
	instead of a conditional merge. It will probably have to be 
	processed separately after all of the rest of the zipping as been 
	applied.

Variable instantiation parse:
	Allow for instantiate and assign in one instruction. Allow for the 
	instantiation of multiple variables of the same type in one 
	instruction.

State space generation:
	Plug known values into passive transitions (guards).

Miscellaneous:
	Flesh out the error handling archecture. As of now errors are simply 
	printed to the screen and don't stop the compilation even if that 
	error would cause the compiler to crash later on. Make sure to try 
	to identify every possible failure point and create a message for 
	that. Also, create documentation for that message.

Simulate:
	Deadlock Checking
	Untangle synchronization events
	Determine when a guard is unstable (i.e. we need a synchronizer instead of just an arbiter)

Miscellaneous:
	Make sure that arbitration works. Right now I do not handle the thin 
	bar.

Miscellaneous:
	Allow for interprocess shared variable checks. For example, if two 
	processes are using the send functionality of a channel, make sure 
	that the two processes are not conflicting with eachother and causing 
	a short.

Miscellaneous:
	Allow the user to insert a "prs" block.

Refactoring:
	Move everything out of utility.h. The file is unessessary and 
	problematic. common.h should be able to handle a lot of that same 
	stuff.

Assertions
	Sidenote... Embed Perl, allow user to write their own functions to do this kind of thing...

Assumptions
	process p(args...) : assume(DI)		// Asynchronous Delay Insensitive
	{
	}

	process p(args...) : assume(QDI)	// Asynchronous Quasi Delay Insensitive, isochronic fork
	{
	}

	process p(args...) : assume(BOUNDED)	// Asynchronous Bundled Data, bounded delay
	{
	}

	process p(args...) : assume(MESOSYNC)	// MesoSynchronous, interference
	{
	}

	process p(args...) : assume(SYNC)	// Synchronous, instability
	{
	}

Expand Inconsistent Branches:
	Example:
	[	i  -> r.t,r.f := 1,0
	[]	~i -> r.t,r.f := 0,1
	];[a]; r.t,r.f := 0,0; [~a];
	into
	[	i  -> r.t,r.f := 1,0;[a]; r.t,r.f := 0,0;
	[]	~i -> r.t,r.f := 0,1;[a]; r.t,r.f := 0,0;
	]; [~a];


Handshaking reshuffling
Production Rule Reduction
Bubble Reshuffling
Performance analysis (Power, Timing, ect)
Comment Code